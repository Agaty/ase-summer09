#summary System Design Document

Akhil Chopra<br>
Chad Gabrysch<br>
Katie Roberts Hoffman<br>
Rajeev Sharma<br>
Ryan Kelly<br>

Project website: [http://code.google.com/p/ase-summer09 http://code.google.com/p/ase-summer09]

Wiki website: [http://code.google.com/p/ase-summer09/w/list]

* Table of Contents *

<wiki:toc max_depth="5" />

= System Design Document =

== 1. Introduction == 
    === _1.1 Purpose of the system_ ===
The ADS system under consideration will facilitate the orderly and timely direction of ambulances throughout a metropolitan area to minimize the loss of human life.

    === _1.2 Design goals_ ===
The major design goal is to have a high cohesion and low coupling. The system is divided into sub-systems taking into consideration the fact that the MVC architecture style which is a special case of repository architecture style is preserved. The notion behind MVC is the client server and the closed layered architecture style. The design goals basically can be traced to the non-functional requirements of modularity, robust-ability and fault tolerance.

We will consider the following design goals with the highest priority items appearing first:

  * Functionality
  * Increased Productivity
  * Minimum Errors
  * Fault Tolerant
  * Good Documentation
  * Security
  * Flexibility
  * Low Cost
  * User Friendliness
  * Modifiability
  * Traceability of Requirements

    === _1.3 References_ ===
[http://code.google.com/p/ase-summer09/wiki/Phase_02]
    === _1.4 Overview_ ===
In general the architectural is defined as the underlying structure of things. The architecture gives an abstract solution to conquer complexity. The system is divided into sub sub-systems which in turn supports reuse, facilitates testing, parallel development and system evolvability.

== 2. Current software architecture ==
 
The current system has no prevalent architecture, so for coming up with the architecture for the system a short review of popular architectural styles is presented which has been taken from Dr Chung’s class discussion and slides.

*2.1.1 Client-Server Architecture*

The client server architecture consists of one or many servers which provide services to instances of subsystems, called clients. The client requests a service to the server, which in turn looks up for the service and returns the result back to the client.

The client has the knowledge about the server services and knows the server interface. The server has no knowledge about the client interface. 
The client server interaction in general is immediate and the users interact only with the client.

*2.1.2 Layered Architecture*

The layered architecture is based on horizontal layering of the system with each layer providing a set of services and known as Virtual Machines.

Closed Layer: Any layer can only invoke operations from the immediate layer below. The design goals are high maintainability, flexibility because even any layer is affected the subsequent effect is not spread across the layers. This also enables the closed architecture to have high fault tolerance and portability. On the other hand the closed layer architecture becomes complex with increasing size with the introduction of dummies. Also closed architecture has low runtime efficiency.

Open Layer: Any layer can invoke operations from any layers below with design goal of having high runtime efficiency and thus it violates the true spirit of the layered architecture. This style is not fault tolerant but is easy to understand. 

Example of Layered Architecture is the OSI Network Layer Model

*2.1.3 Peer-to-Peer Architecture*

“Peer-to-peer (P2P) networking is a method of delivering computer network services in which the participants share a portion of their own resources, such as processing power, disk storage, network bandwidth, printing facilities. Such resources are provided directly to other participants without intermediary network hosts or servers.Peer-to-peer network participants are providers and consumers of network services simultaneously, which contrasts with other service models, such as traditional client-server computing.” Source: Dr Chung Course Slide

*2.1.4 Repository Architecture*

The repository architecture is composed of three sub-systems:
Knowledge source: It is responsible for the application domain knowledge.

Controller: It is responsible for controlling the sequence of actions of the interactions between the user i.e the knowledge source and inform it about the corresponding changes in the model.

Blackboard: It is responsible for displaying the domain objects requested by the user.

The MVC is a special case of a repository architecture wherein knowledge source subsystem implements the central data structure; the controller subsystem explicitly dictates the control flow. Thus there is a two way communication which differs from the traditional data base repository architecture which has only one way communication.

The Subsystems access and modify data from a single data structure with the primary design goal of low coupling. The Control flow is dictated by central knowledge source.
Example of repository architecture is Microsoft Speech Recognition system.

*2.1.5 Middleware Architecture*

The middleware architecture provides many services one of being the translation services between subsystems which allows communication between two different subsystems. The communications happens via a software bus which is the underlying communication between the various sub-systems.



Other popular architecture style are:
•	Pipes and Filter
•	Data Abstraction and Object oriented architecture 
•	Event Based Implicit Invocation


== 3. Proposed software architecture == 

The third section documents the system design model of the new system.  

    === _3.1 Overview_ ===
The overall design is client-server over the web with a 3 layered architecture.  The view runs on the client and is displayed in a web browser.  The view makes control requests to the Controller via the provided interface.  The controller then gets and sets attributes of the model which is the third layer.  The model is an active record running off of a SQL database.
    === _3.2 Subsystem decomposition_ ===
http://ase-summer09.googlecode.com/files/component.png
    === _3.3 Hardware/software mapping_ ===
The client only requires a basic computer running a web browser with a connection to the server.

The server requires access to the database and sufficient computing power to handle the load of users expected.

http://ase-summer09.googlecode.com/files/deployment.png

    === _3.4 Persistent data management_ ===
We'll use Active records to store the model to an MySQL database.
    === _3.5 Access control and security_ ===
Users will be logged into the system.  Client systems must maintain their own physical and data security.
    === _3.6 Global software control_ === 
User uses the view to make requests and is provided with responses.  The view communicates through the controller to the model.  The model provides an interface to get and set attributes.  The controller handles all requests.
    === _3.7 Boundary conditions_ ===  
The server needs to be running for the clients to connect.  If a client shuts down there is no significant effect.  If the server shuts down clients requests will time out and fail.
== 4. Subsystem services == 
The interface provided by the model allows the getting and setting of attributes within the model.

The interface provided by the controller allows user requests to be handled.

The view is interacted with directly by the user.
== 5. Glossary ==  

MVC: Model View Controller 