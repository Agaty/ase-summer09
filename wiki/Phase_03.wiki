#summary System Design Document

Akhil Chopra<br>
Chad Gabrysch<br>
Katie Roberts Hoffman<br>
Rajeev Sharma<br>
Ryan Kelly<br>

Project website: [http://code.google.com/p/ase-summer09 http://code.google.com/p/ase-summer09]

Wiki website: [http://code.google.com/p/ase-summer09/w/list]

* Table of Contents *

<wiki:toc max_depth="5" />


=== Version ===
|| *Version* || *Date* || *Author* || *Comments                                   * ||
|| 0.1 || 6/6/09 || Katie || Initial draft ||
|| 0.2 || 6/27/09 || Ryan, Chad, Katie || Drafted Section 3 in Team Meeting on 6/27 ||
|| 0.3 || 7/5/09 || Akhil || Subsystem and deployment diagrams ||
|| 0.4 || 7/5/09 || Rajeev || Added to 3.2-3.4 ||
|| 0.5 || 7/5/09 || Akhil || Reformatted Section 2 ||
|| 0.6 || 7/5/09 || Katie || Edited document for consistancy and clarity ||

= System Design Document =

== 1. Introduction == 
    === _1.1 Purpose of the system_ ===
The Ambulance Dispatch System (ADS) system under consideration will facilitate the orderly and timely direction of ambulances throughout a metropolitan area to minimize the loss of human life. Further information regarding this project's requirements and scope can be found at the project's website: [http://code.google.com/p/ase-summer09 http://code.google.com/p/ase-summer09].

    === _1.2 Design goals_ ===
As in many software projects, the primary design goal is to maximize cohesion and reduce coupling. This philosophy can be examined in further detail in Bruegge's book Object-Oriented Software Engineering: Using UML, Patterns and Java.

This ADS project is divided into sub-systems using the MVC architecture style. This special case of repository architecture uses ideas from the MVC (Model, View, Controller) and cloud layered architecture styles. The following design goals can be directly traced to the non-functional requirements (see the ADS project website for details) where emphasis was placed on modularity, robustness and fault tolerance.

Below we outline a number of design goals that will be explicitly addressed in our ADS, with the design goals listed first receiving higher priority:

  * Functionality (See the Requirements Analysis Document for further functional requirements)
  * Increased Productivity (over the existing, non-software based system)
  * Minimum Errors
  * Fault Tolerant
  * Good Documentation
  * Security
  * Flexibility
  * Low Cost
  * User Friendliness
  * Modifiability
  * Traceability of Requirements

    === _1.3 References_ ===

  * [http://code.google.com/p/ase-summer09/wiki/Phase_02 Phase 2: Requirements Analysis]
  * [http://wwwbruegge.in.tum.de/OOSE/ Bruegge's website on Object Oriented Software Engineering]
  * [http://utdallas.edu/~chung/CS6354/ Dr. Chung's CS 6354 Class Notes]

    === _1.4 Overview_ ===

The architecture of a system is defined as the structure of the system's components. In this document, the Architecture Specification, we provide details on subsystem decomposition, hardware/software mapping, data management, and security. We spend significant effort on the subsystem decomposition since this abstraction reduces complexity and in turn supports re-use, testing, and parallel development.

This document is intended for both project managers as well as the implementors of each individual subsystem.

== 2. Current software architecture ==
 
The current system has no prevalent architecture, so for coming up with the architecture for the system a short review of popular architectural styles is presented which has been taken from Dr Chung’s class discussion and slides.

    === _2.1 Client-Server Architecture_ ===

The client server architecture consists of one or many servers which provide services to instances of subsystems, called clients. The client requests a service to the server, which in turn looks up for the service and returns the result back to the client.

The client has the knowledge about the server services and knows the server interface. The server has no knowledge about the client interface. 
The client server interaction in general is immediate and the users interact only with the client.

    === _2.2 Layered Architecture_ ===

The layered architecture is based on horizontal layering of the system with each layer providing a set of services and known as Virtual Machines.

Closed Layer: Any layer can only invoke operations from the immediate layer below. The design goals are high maintainability, flexibility because even any layer is affected the subsequent effect is not spread across the layers. This also enables the closed architecture to have high fault tolerance and portability. On the other hand the closed layer architecture becomes complex with increasing size with the introduction of dummies. Also closed architecture has low runtime efficiency.

Open Layer: Any layer can invoke operations from any layers below with design goal of having high runtime efficiency and thus it violates the true spirit of the layered architecture. This style is not fault tolerant but is easy to understand. 

Example of Layered Architecture is the OSI Network Layer Model

    === _2.3 Peer-to-Peer Architecture_ ===

“Peer-to-peer (P2P) networking is a method of delivering computer network services in which the participants share a portion of their own resources, such as processing power, disk storage, network bandwidth, printing facilities. Such resources are provided directly to other participants without intermediary network hosts or servers.Peer-to-peer network participants are providers and consumers of network services simultaneously, which contrasts with other service models, such as traditional client-server computing.” Source: Dr Chung Course Slide

    === _2.4 Repository Architecture_ ===

The repository architecture is composed of three sub-systems:

Knowledge source: It is responsible for the application domain knowledge.

Controller: It is responsible for controlling the sequence of actions of the interactions between the user i.e the knowledge source and inform it about the corresponding changes in the model.

Blackboard: It is responsible for displaying the domain objects requested by the user.

The MVC is a special case of a repository architecture wherein knowledge source subsystem implements the central data structure; the controller subsystem explicitly dictates the control flow. Thus there is a two way communication which differs from the traditional data base repository architecture which has only one way communication.

The Subsystems access and modify data from a single data structure with the primary design goal of low coupling. The Control flow is dictated by central knowledge source.
Example of repository architecture is Microsoft Speech Recognition system.

    === _2.5 Middleware Architecture_ ===

The middleware architecture provides many services one of being the translation services between subsystems which allows communication between two different subsystems. The communications happens via a software bus which is the underlying communication between the various sub-systems.

Other popular architecture style are:
  * Pipes and Filter
  * Data Abstraction and Object oriented architecture 
  * Event Based Implicit Invocation

== 3. Proposed software architecture == 

The third section documents the system design model of the new system.  

    === _3.1 Overview_ ===
The overall design is client-server over the web with a 3 layered architecture.  The view runs on the client and is displayed in a web browser.  The view makes control requests to the Controller via the provided interface.  The controller then gets and sets attributes of the model which is the third layer.  The model is an active record running off of a SQL database.

    === _3.2 Subsystem decomposition_ ===
http://ase-summer09.googlecode.com/files/component.png

  * The ADS system uses the layered architecture system. The system is decomposed into 3 layers:
    * The Model layer
    * The View layer
    * The Controller layer

  * The system also uses the closed form of layered architecture, which thus renders the system more maintainable and flexible for changes.

  * Each of these three layers has subsystems in the form of components that interact with each other to perform its respective tasks.

  * Since each subsystem is single minded and performs only its designated task, it is highly cohesive and thus this also reduces coupling.

  * The Model layer: The model layer corresponds to persistent storing of incident and ambulance data. It consists of the ADS Database subsystem. We are using MySQL database to implement the ADS database subsystem. This subsystem is responsible for creating, retrieving, updating and deleting records from the database.  

  * The View layer: The view layer corresponds to the graphical user interface layer. This layer consists of subsystems responsible for interacting with the various users of the system. The view layer consists of the following subsystems. We also list the services provided by each of these subsystems.

  * The Call taker UI subsystem: The call taker UI subsystem handles the screens that the call taker uses. It provides the following services to the call taker:

    * Create Incidents

    * The Dispatcher UI subsystem: The dispatcher UI subsystem handles the screens that the dispatcher uses. It provides the following services to the dispatcher:
    * View assigned and unassigned incidents
    * View list of ambulances
    * Recall ambulance
    * Review and update incident

  * The Ambulance Admin UI subsystem: The ambulance administrator UI subsystem handles the screens that the ambulance administrator uses. It provides the following services to the ambulance administrator:

    * View list of ambulances
    * Add new ambulance
    * Update the status of ambulance

  * The Controller layer: The controller layer consists of the main controlling subsystems. There are three subsystems one corresponding to each of the three subsystems in the UI layer. And there is one master controller subsystem that receives data from the above three subsystems and passes it onto the model layer to be stored in the persistent database system. The subsystems in the controller layer are as follows:

    * Call Taker controller: The call taker controller subsystem is responsible for receiving data from the call taker UI subsystem and processing it and passing it onto the ADS controller for further processing or saving in the database.

    * Dispatcher controller: The dispatcher controller subsystem is responsible for receiving data from the dispatcher subsystem and processing it and passing it onto the ADS controller for further processing or saving in the database.

    * Ambulance Admin controller: The ambulance admin controller subsystem is responsible for receiving data from the ambulance admin UI subsystem, processing it and passing it onto the ADS controller for further processing or saving in the database.

    * ADS controller: The ADS controller is the main controlling subsystem that is responsible for receiving data from the call taker, dispatcher and ambulance admin controller subsystems, processing it and passing it onto the ADS database subsystem to be stored. This subsystem is also responsible for receiving requests for data from the other controller subsystems and then fetching it from the model layer and passing it onto the requesting controller subsystem.

    === _3.3 Hardware/software mapping_ ===
The client only requires a basic computer running a web browser with a connection to the server.

The server requires access to the database and sufficient computing power to handle the load of users expected.

http://ase-summer09.googlecode.com/files/deployment.png

Here we list the various hardware devices and show how each of the subsystems is mapped to the hardware devices.

  * Web Server: The ADS system uses a web server, which runs the UI and controller subsystems of the call taker, dispatcher and ambulance administrator. The UI is layer is implemented by JSP and the controller by Servlets. 

  * DB Server: The ADS system uses a database to implement the ADS database subsystem. The database used for this purpose is MySQL.

  * The Web browser: The client systems access the ADS software system using a web browser. Since the software is web-based and implemented using JSP, the rendered pages will be in HTML. So any web browser like Internet explorer, Mozilla Fire-Fox shall suffice.

  * The ADS messaging system: This is one of the off-the-shelf products that will be used inside the ambulance by the ambulance drivers. It uses its own custom software that will be part of the device.

  * The GPS: The ambulances have some of the latest and most advanced GPS systems running their own software, updating the location, giving directions and traffic indications.


    === _3.4 Persistent data management_ ===
Here we describe the database schema of the various tables used by our ADS system. The database management system that we are going to use is MySQL 5.0. The tables that we are going to implement are:

  * Incident

  * Caller

  * Patient

  * Ambulance

  * Hospital

  * User

The Incident relation has the following attributes: Incident ID, number of people affected, severity, location, date and time of incident, age and sex of patient, type of problem, and other details.

The Caller relation has the following attributes: Caller ID, name, relation to patient, location, and phone.

The Patient relation has the following attributes: Patient ID, name , address, phone, insurance provider, allergies, previous health history, family doctor, emergency contact information.

The Ambulance relation has the following attributes: Ambulance ID, registration number, designated driver, emergency facilities available, current location, availability.

The Hospital relation has the following attributes: Hospital ID, name, address, phone, facilities available, number of doctors, number of nurses, and number of wards currently available.

The User relation has the following attributes: User ID, password, role, supervisor, contact address, and phone.

    === _3.5 Access control and security_ ===
Users will be logged into the system.  Client systems must maintain their own physical and data security.
    === _3.6 Global software control_ === 
User uses the view to make requests and is provided with responses.  The view communicates through the controller to the model.  The model provides an interface to get and set attributes.  The controller handles all requests.
    === _3.7 Boundary conditions_ ===  
The server needs to be running for the clients to connect.  If a client shuts down there is no significant effect.  If the server shuts down clients requests will time out and fail.

== 4. Subsystem services == 
The interface provided by the model allows the getting and setting of attributes within the model.

The interface provided by the controller allows user requests to be handled.

The view is interacted with directly by the user.

== 5. Glossary ==  

  * ADS: Ambulance Dispatch System (the system being designed)
  * GPS: Global Positioning System (to be used by ambulance drivers)
  * MVC: Model View Controller Architecture