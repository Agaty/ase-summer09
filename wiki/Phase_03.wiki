#summary System Design Document

Akhil Chopra<br>
Chad Gabrysch<br>
Katie Roberts Hoffman<br>
Rajeev Sharma<br>
Ryan Kelly<br>

Project website: [http://code.google.com/p/ase-summer09 http://code.google.com/p/ase-summer09]

Wiki website: [http://code.google.com/p/ase-summer09/w/list]

* Table of Contents *

<wiki:toc max_depth="5" />


=== Version ===
|| *Version* || *Date* || *Author* || *Comments                                   * ||
|| 0.1 || 6/6/09 || Katie || Initial draft ||
|| 0.2 || 6/27/09 || Ryan, Chad, Katie || Drafted Section 3 in Team Meeting on 6/27 ||
|| 0.3 || 7/5/09 || Akhil || Subsystem and deployment diagrams ||
|| 0.4 || 7/5/09 || Rajeev || Added to 3.2-3.4 ||
|| 0.5 || 7/5/09 || Akhil || Reformatted Section 2 ||
|| 0.6 || 7/5/09 || Katie || Edited document for consistancy and clarity ||
|| 0.7 || 7/6/09 || Katie || Added 3.5-3.7, 4, Edited 3.1-3.4  ||

= System Design Document =

== 1. Introduction == 
    === _1.1 Purpose of the system_ ===
The Ambulance Dispatch System (ADS) under consideration will facilitate the orderly and timely direction of ambulances throughout a metropolitan area to minimize the loss of human life. Further information regarding this project's requirements and scope can be found at the project's website: [http://code.google.com/p/ase-summer09 http://code.google.com/p/ase-summer09].

    === _1.2 Design goals_ ===
As in many software projects, the primary design goal is to maximize cohesion and reduce coupling. This philosophy can be examined in further detail in Bruegge's book Object-Oriented Software Engineering: Using UML, Patterns and Java.

This ADS project is divided into sub-systems using the MVC architecture style. This special case of repository architecture uses ideas from the MVC (Model, View, Controller) and cloud layered architecture styles. The following design goals can be directly traced to the non-functional requirements (see the ADS project website for details) where emphasis was placed on modularity, robustness and fault tolerance.

Below we outline a number of design goals that will be explicitly addressed in our ADS, with the design goals listed first receiving higher priority:

  * Functionality (See the Requirements Analysis Document for further functional requirements)
  * Increased Productivity (over the existing, non-software based system)
  * Minimum Errors
  * Fault Tolerant
  * Good Documentation
  * Security
  * Flexibility
  * Low Cost
  * User Friendliness
  * Modifiability
  * Traceability of Requirements

    === _1.3 References_ ===

  * [http://code.google.com/p/ase-summer09/wiki/Phase_02 Phase 2: Requirements Analysis]
  * [http://wwwbruegge.in.tum.de/OOSE/ Bruegge's website on Object Oriented Software Engineering]
  * [http://utdallas.edu/~chung/CS6354/ Dr. Chung's CS 6354 Class Notes]

    === _1.4 Overview_ ===

The architecture of a system is defined as the structure of the system's components. In this document, the Architecture Specification, we provide details on subsystem decomposition, hardware/software mapping, data management, and security. We spend significant effort on the subsystem decomposition since this abstraction reduces complexity and in turn supports re-use, testing, and parallel development.

This document is intended for both project managers as well as the implementers of each individual subsystem.

== 2. Current software architecture ==
 
The current system has no prevalent architecture since it was not a software-based dispatch system. Since the intended client may not be familiar with common software architectures, we outline them below for clarity. These outlines are based on notes of Dr. Chung that are available at [http://utdallas.edu/~chung/CS6354/ http://utdallas.edu/~chung/CS6354/].

    === _2.1 Client-Server Architecture_ ===

The client-server architecture consists of one or many servers which provide services to instances of subsystems, called clients. The client requests a service to the server, which in turn invokes the service and returns the result back to the client.

The client requires knowledge about the available server services and corresponding server interface. The server on the other hand, requires no knowledge about the client's interface. Users typically interact only with the client.

    === _2.2 Layered Architecture_ ===

The layered architecture involves the horizontal layering of the system with each layer providing a set of services. Each layer is commonly referred to as a Virtual Machine. There are two types of layered architecture systems as outlined below:

Closed Layer: Any layer can only invoke operations from the immediate layer below. This architecture achieves the design goals of high maintainability and flexibility because changes to a single layer do not spread across other layers. This also enables the closed architecture to have high fault tolerance and portability. On the other hand the closed layer architecture becomes complex with increasing size. In general, closed architecture are also less efficient at runtime than open layered systems. 

Open Layer: In this architecture, any layer can invoke operations from any layer beneath it. It achieves the design goal of high runtime efficiency. While this style is not fault tolerant, it is easy to understand. 

    === _2.3 Peer-to-Peer Architecture_ ===

Peer-to-peer (P2P) networking is a method of delivering computer services amongst a set of participants. Each participant shares a portion of their own resources, such as processing power, disk storage, network bandwidth, printing facilities. These resources are provided directly to other participants without intermediary network hosts or servers. Thus P2P network participants are both providers and consumers of services simultaneously in contrast with other service models.

    === _2.4 Repository Architecture_ ===

The repository architecture is composed of three sub-systems:

Knowledge source: It is responsible for the application domain knowledge.

Controller: It is responsible for controlling the sequence of actions following interactions between the user or changes in the model.

Blackboard: It is responsible for displaying the domain objects requested by the user.

The MVC is a special case of a repository architecture where a knowledge source subsystem implements the central data structure and the controller subsystem explicitly dictates the control flow. Thus there is two-way communication which differs from the traditional repository architecture which has only one way communication. The control flow is dictated by the central knowledge source.

The subsystems access and modify data from a single data structure. Thus this achieves the initial design goal of reducing coupling.

Example of repository architecture is Microsoft Speech Recognition system.

    === _2.5 Middleware Architecture_ ===

The middleware architecture involves the interaction amongst subsystems, but not in a layered approach. This architecture requires translation services to allow subsystems to communicate with one another. Many times, subsystems are written in different languages. Note that not all subsystems can communicate directly with each other. 

    === _2.6 Other Architecutres_ ===

While not explored in detail, other popular architecture styles include:
  * Pipes and Filter
  * Data Abstraction and Object oriented architecture 
  * Event Based Implicit Invocation

== 3. Proposed software architecture == 

Following the brief summary of existing software architectures above, we now outline the ADS design model. 

    === _3.1 Overview_ ===
The ADS will use a client-server model with an MVC architecture to maximally achieve the design goals set forth in Section 1. We shall discuss particular advantages to this design in the following section, although the architecture seems to fit for the following reasons:
  * Our highest priority design goals (Functionality, increased productivity, minimum errors, and good documentation) should be achievable regardless of the architecture, thus we focus on the remaining design goals.
  * The client-server model works particularly well for systems requiring high fault tolerance since we have assumed our system supports multiple servers, to be located at various locations. Thus our architecture must support the seamless connection between many clients and any number of servers. 
  * The client-server model over the web also has a number of off-the-shelf security options. 
  * MVC is a centralized design that allows for easy modifications to the control structure. The main drawback of a centralized design may be that bottlenecks occur during model access, however, the amount of computation occuring in this system is assumed to be minimal and that the servers shall be adequately equipped to handle requests. Thus MVC naturally meets the design goals of flexibility and modifiability. This may also help meet the low cost design goal.
  * Finally, the client-server and MVC models support client-side GUIs and server-side databases. The clients can support appealing GUIs which increases the usability of the system (thus meeting the user friendliness design goal)
  
A high level summary of the ADS MVC model is as follows:
  * The view runs on the client and is displayed in a web browser.  
  * The view makes control requests to the Controller via the provided interface.  
  * The controller then gets and sets attributes of the model which is the third layer. 
  * The model is an active record running off of an SQL database.

    === _3.2 Subsystem decomposition_ ===
http://ase-summer09.googlecode.com/files/component.png

  * The ADS system uses the MVC model which is a layered architecture system. The system is decomposed into the three layers previously discussed:
    * The Model layer
    * The View layer
    * The Controller layer

The ADS uses a closed form of layered architecture, which thus renders the system more maintainable and flexible for changes. Each of the three layers have subsystems in the form of components that interact with each other to perform their respective tasks. Since each subsystem is single-minded and only performs  its designated tasks, it is highly cohesive and thus this also reduces coupling which thus satisfied the principle software design goal.

Each of the layers is now discussed in further detail:

  * *The Model layer*: The model layer corresponds to persistent storing of incident and ambulance data. It consists of the ADS Database subsystem. We are using MySQL database to implement the ADS database subsystem. This subsystem is responsible for creating, retrieving, updating and deleting records from the database.  
  * *The View layer*: The view layer corresponds to the graphical user interface layer. This layer consists of subsystems responsible for interacting with the various users of the system. The view layer consists of the following subsystems. We also list the services provided by each of these subsystems.
    * The Call taker UI subsystem: The call taker UI subsystem handles the screens that the call taker uses. It provides the following services to the call taker:
      * Create Incidents
    * The Dispatcher UI subsystem: The dispatcher UI subsystem handles the screens that the dispatcher uses. It provides the following services to the dispatcher:
      * View assigned and unassigned incidents
      * View list of ambulances
      * Recall ambulance
      * Review and update incident
    * The Ambulance Admin UI subsystem: The ambulance administrator UI subsystem handles the screens that the ambulance administrator uses. It provides the following services to the ambulance administrator:
      * View list of ambulances
      * Add new ambulance
      * Update the status of ambulance
  * *The Controller layer*: The controller layer consists of the main controlling subsystems. There are three subsystems one corresponding to each of the three subsystems in the UI layer. And there is one master controller subsystem that receives data from the above three subsystems and passes it onto the model layer to be stored in the persistent database system. The subsystems in the controller layer are as follows:
    * Call Taker controller: The call taker controller subsystem is responsible for receiving data from the call taker UI subsystem and processing it and passing it onto the ADS controller for further processing or saving in the database.
    * Dispatcher controller: The dispatcher controller subsystem is responsible for receiving data from the dispatcher subsystem and processing it and passing it onto the ADS controller for further processing or saving in the database.
    * Ambulance Admin controller: The ambulance admin controller subsystem is responsible for receiving data from the ambulance admin UI subsystem, processing it and passing it onto the ADS controller for further processing or saving in the database.
    * ADS controller: The ADS controller is the main controlling subsystem that is responsible for receiving data from the call taker, dispatcher and ambulance admin controller subsystems, processing it and passing it onto the ADS database subsystem to be stored. This subsystem is also responsible for receiving requests for data from the other controller subsystems and then fetching it from the model layer and passing it onto the requesting controller subsystem.

    === _3.3 Hardware/software mapping_ ===

The client only requires a basic x86-based computer running a web browser with a connection to the server.

The server requires access to the ADS database and sufficient computing power to handle the load of users expected.

http://ase-summer09.googlecode.com/files/deployment.png

Here we list the various hardware devices and show how each of the subsystems is mapped to the hardware devices.

  * Web Server: The ADS system uses a web server, which runs the UI and controller subsystems of the call taker, dispatcher and ambulance administrator. The UI is layer is implemented by JSP and the controller by Servlets. 
  * Database Server: The ADS system uses a database to implement the ADS database subsystem. The database used for this purpose is MySQL.
  * The Web browser: The client systems access the ADS software system using a web browser. Since the software is web-based and implemented using JSP, the rendered pages will be in HTML. So any web browser like Internet explorer, Mozilla Fire-Fox shall suffice.
  * The ADS messaging system: This is one of the off-the-shelf products that will be used inside the ambulance by the ambulance drivers. It uses its own custom software that will be part of the device.
  * The GPS: The ambulances have some of the latest and most advanced GPS systems running their own software, updating the location, giving directions and traffic indications.

    === _3.4 Persistent data management_ ===
Here we describe the database schema of the various tables used by our ADS system. The database management system that we are going to use is MySQL 5.0. The tables that we are going to implement are as follows and directly correspond to the Object Model diagrams in the Requirements Analysis document:

  * The Incident relation has the following attributes: Incident ID, number of people affected, severity, location, date and time of incident, age and sex of patient, type of problem, and other details.
  * The Caller relation has the following attributes: Caller ID, name, relation to patient, location, and phone.
  * The Patient relation has the following attributes: Patient ID, name , address, phone, insurance provider, allergies, previous health history, family doctor, emergency contact information.
  * The Ambulance relation has the following attributes: Ambulance ID, registration number, designated driver, emergency facilities available, current location, availability.
  * The Hospital relation has the following attributes: Hospital ID, name, address, phone, facilities available, number of doctors, number of nurses, and number of wards currently available.
  * The User relation has the following attributes: User ID, password, role, supervisor, contact address, and phone.

    === _3.5 Access control and security_ ===
In this system we have a number of actors (such as Ambulance Dispatchers, Ambulance Administrators, and Ambulance Drivers), each with specific, and sometimes exclusive roles. For more details on these roles, see the Requirements Analysis document. 

We have assumed that each user must successfully log into a computer to gain access to starting any client program. Each client program shall only expose the appropriate view to the user. Thus a person tasked with both Ambulance Dispatch and Ambulance Administrator duties shall have two clients accessible on their computer; one Ambulance Dispatch View and another Ambulance Administrator view. Each client only shows permitted activities in their respective GUIs thus limiting the access to the model. Additional security may also be implemented to insure that clients cannot be modified to gain undesired access to the model.

An access diagram is not provided as it can easily be interpolated from the Requirements Analysis document diagrams.

    === _3.6 Global software control_ === 

The MVC architecture is an event-driven centrally controlled software system. The system controller handles all requests. System users use the view to make requests and are provided with responses.  The view communicates through the controller to the model.  The model provides an interface to get and set attributes. Further details on MVC software control can be found in Bruegge's Object Oriented Software Engineering textbook.

    === _3.7 Boundary conditions_ ===  

We consider three boundary condition scenarios. Complete use cases are not provided as the scenarios are not complex.

  * Initialization: The server must be started prior to the connection of any clients. This shall be done by the Ambulance Administrator who shall then select to use data currently stored in the system database (i.e. present locations of the ambulances, unhandled incidents, etc.) or create a new system database (which would result in an empty database). Following the latter initialization, the Ambulance Administrator would then be required to add ambulances to the system.
  * Termination: If a client disconnects, either intentionally (i.e. by logging out of the system) or unintentionally (i.e. unresponsive computer), this shall have no effect to the server. If the server shuts down, then each of the clients requests shall time out and an error shall be reported in the client's GUI.
  * Failure: Failure of either the server or clients shall be treated the same as in the termination scenario.

== 4. Subsystem services == 

This section is intended to describe the services provided by each subsystem. This will be addressed in detail in the Component/Object Specification document to be released by the end of July. Until this time, we initially provide the following references:

  * View: The view (GUI) directly interacts with the end user (i.e. Ambulance Dispatchers, Ambulance Administrators, and Ambulance Drivers). We have provided Navigational Path diagrams and screen mock-ups in the Requirements Analysis document which allude to the services provided by each view.
  * Interface: The interface provided by the model allows the retrieving and setting of attributes within the model. The functions associated with each object can be found within the Object Model in the Requirements Analysis document. This will lead to the development of an interface to be provided by the controller which would allow user requests to be handled. This interface shall be developed fully in the Component/Object Specification document.

== 5. Glossary ==  

  * ADS: Ambulance Dispatch System (the system being designed)
  * GPS: Global Positioning System (to be used by ambulance drivers)
  * MVC: Model View Controller Architecture